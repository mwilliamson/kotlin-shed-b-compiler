// stdout:
//   effect1
//   effect2a
//   effect2b
//   effect1inner
//   effect1outer
export main;

effect Effect1 {
    .leave: () -> Nothing,
}

effect Effect2 {
    .leave: () -> Nothing,
}

fun main() !Io -> Unit {
    // Nested handlers for different effects, outer effect
    print!(handle Effect1 {
        handle Effect2 {
            Effect1.leave!()
        } on {
            .leave = () {
                "effect2\n"
            },
        }
    } on {
        .leave = () {
            "effect1\n"
        },
    });

    // Nested handlers for different effects, inner effect
    print!(handle Effect1 {
        handle Effect2 {
            Effect2.leave!()
        } on {
            .leave = () {
                "effect2a\n"
            },
        } + handle Effect2 {
            Effect2.leave!()
        } on {
            .leave = () {
                "effect2b\n"
            },
        }
    } on {
        .leave = () {
            "effect1\n"
        },
    });

    // Nested handlers for same effects uses inner-most effect handler
    print!(handle Effect1 {
        handle Effect2 {
            handle Effect1 {
                Effect1.leave!()
            } on {
                .leave = () {
                    "effect1inner\n"
                },
            }
        } on {
            .leave = () {
                "effect2\n"
            },
        }
    } on {
        .leave = () {
            "effect1outer\n"
        },
    });

    // Nested effect handlers for same effect, can raise effect in handler
    print!(handle Effect1 {
        handle Effect2 {
            handle Effect1 {
                Effect1.leave!()
            } on {
                .leave = () {
                    Effect1.leave!()
                },
            }
        } on {
            .leave = () {
                "effect2\n"
            },
        }
    } on {
        .leave = () {
            "effect1outer\n"
        },
    });
}
