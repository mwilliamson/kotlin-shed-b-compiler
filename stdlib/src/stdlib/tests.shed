import .matchers;
import .options;


shape AssertionError {
    message: String,
}

fun fail(message: String) -> AssertionResult {
    AssertionResult(error = options.some(AssertionError(message = message)))
}

fun assert(value: Bool) -> AssertionResult {
    if (value) {
        AssertionResult(error = options.none)
    } else {
        fail("value was false")
    }
}

fun assertThat[T](value: T, matcher: matchers.Matcher[T]) -> AssertionResult {
    val result = matcher.match(value);
    when (result) {
        is matchers.Failure {
            val message = "expected " + matcher.description + "\nbut " + result.message;
            val error = AssertionError(message = message);
            AssertionResult(error = options.some(error))
        }
        is matchers.Success {
            AssertionResult(error = options.none)
        }
    }
}

shape AssertionResult {
    error: options.Option[AssertionError],
}

union Test = TestCase | TestSuite;
union TestResult = TestCaseResult | TestSuiteResult;

shape TestCase memberOf Test {
    name: String,
    run: () -> AssertionResult,
}

shape TestCaseResult memberOf TestResult {
    name: String,
    error: options.Option[AssertionError],
}

fun testCase(name: String, run: () -> AssertionResult) -> TestCase {
    TestCase(name = name, run = run)
}

shape TestSuite memberOf Test {
    name: String,
    tests: List[Test],
}

shape TestSuiteResult memberOf TestResult {
    name: String,
    results: List[TestResult],
}

fun suite(name: String, tests: List[Test]) -> Test {
    TestSuite(name = name, tests = tests)
}

fun main() -> Int {
    0
}

val greenCode = "\u001B[32m";
val redCode = "\u001B[31m";
val blackCode = "\u001B[39m";

fun runTests(tests: List[Test]) !Io -> Int {
    val results = map(runTest ~ (depth = 0), tests);
    print("\n");
    forEach(printFailures, results);
    if (isAllSuccess(results)) {
        0
    } else {
        1
    }
}

fun isAllSuccess(results: List[TestResult]) -> Bool {
    all(map(isSuccess, results))
}

fun isSuccess(result: TestResult) -> Bool {
    when (result) {
        is TestCaseResult {
            result.error is options.None
        }
        is TestSuiteResult {
            isAllSuccess(result.results)
        }
    }
}

fun printFailures(result: TestResult) !Io -> Unit {
    // TODO: formatting of suites
    when (result) {
        is TestCaseResult {
            val error = result.error;
            if (error is options.Some[AssertionError]) {
                print("\n");
                print(redCode);
                print("✖ ");
                print(result.name);
                print(":\n");
                print(error.value.message);
                print(blackCode);
                print("\n\n");
            }
        }
        is TestSuiteResult {
            forEach(printFailures, result.results);
        }
    }
}

fun runTest(test: Test, *, depth: Int) !Io -> TestResult {
    when (test) {
        is TestCase {
            val result = test.run();
            val error = result.error;

            when (error) {
                is options.Some[AssertionError] {
                    print(redCode);
                    print("✖");
                }
                is options.None {
                    print(greenCode);
                    print("✔");
                }
            }
            print(blackCode);
            TestCaseResult(name = test.name, error = result.error)
        }
        is TestSuite {
            // TODO: printing of suite names
            // TODO: indentation
            val results = map(runTest ~ (depth = depth + 1), test.tests);
            TestSuiteResult(name = test.name, results = results)
        }
    }
}
