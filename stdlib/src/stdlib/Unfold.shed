import stdlib.Sequences;

union Next[R, T] = End | Continue[R, T];

shape End {
}

val end = End();

shape Continue[R, T] {
    element: R,
    remainder: T,
}

fun continue[R, T](element: R, remainder: T) -> Continue[R, T] {
    Continue(element = element, remainder = remainder)
}

fun unfold[R, T, !E](next: (T) -> Next[R, T], value: T) !E -> Sequences.Sequence[R, E] {
    Sequences.Sequence(
        next = fun () -> Sequences.SequenceIterator[R, E] {
            val result = next(value);
            when (result) {
                is Continue[R, T] {
                    Sequences.SequenceItem(
                        head = result.element,
                        tail = unfold(next, result.remainder),
                    )
                }
                is End {
                    Sequences.end
                }
            }
        },
    )
}


