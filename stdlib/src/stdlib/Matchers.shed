import .Options;
import .Types;

fun anything() -> Matcher[Any] {
    Matcher(
        description = "anything",
        match = fun (x: Any) => success,
    )
}

fun isInteger(value: Int) -> Matcher[Int] {
    describingMatcher(
        value,
        fun (integer: Int) => intToString(integer),
        fun (actual: Int) => actual == value,
    )
}

fun isString(value: String) -> Matcher[String] {
    describingMatcher(
        value,
        fun (string: String) => string,
        fun (actual: String) => actual == value,
    )
}

fun isNone() -> Matcher[Options.Option[Any]] {
    Matcher(
        description = "none",
        match = fun (actual: Options.Option[Any]) -> Result {
            if (actual is Options.None) {
                success
            } else {
                failure("was some()")
            }
        }
    )
}

fun isSome[T](matcher: Matcher[T]) -> Matcher[Options.Option[T]] {
    Matcher(
        description = "option with value " + matcher.description,
        match = fun (actual: Options.Option[T]) -> Result {
            if (actual is Options.Some[T]) {
                matcher.match(actual.value)
            } else {
                failure("was none")
            }
        }
    )
}

fun isInstance[T](type: Type[T], matcher: Matcher[T]) -> Matcher[Any] {
    Matcher(
        description = "instance of " + Types.name(type),
        match = fun(actual: Any) {
            val result = Types.cast(type, actual);
            when (result) {
                is Options.Some[T] {
                    matcher.match(result.value)
                }
                is Options.None {
                    failure("was instance of " + Types.name(Types.typeOf(actual)))
                }
            }
        },
    )
}

fun describingMatcher[T](
    value: T,
    toString: (T) -> String,
    match: (T) -> Bool
) -> Matcher[T] {
    Matcher(
        description = toString(value),
        match = fun (actual: T) -> Result {
            if (match(actual)) {
                success
            } else {
                failure("was " + toString(actual))
            }
        },
    )
}

shape Matcher[-T] {
    description: String,
    match: (T) -> Result,
}

union Result = Success | Failure;
shape Success { }
shape Failure {
    message: String,
}
val success = Success();
fun failure(message: String) -> Failure {
    Failure(message=message)
}
