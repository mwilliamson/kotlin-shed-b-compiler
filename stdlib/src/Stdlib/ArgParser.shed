export ParseResult, Success, Failure, parser, parse, positional, optional, string;

import Lists from .Lists;
import Options from .Options;
import Sequences from .Sequences;

shape Parser[T] {
    argDefinitions: Lists.List[ArgDefinition],
    parseStringArgs: Fun (StringArgs) -> ParseResult[T],
}

shape ArgDefinition {
    name: String,
}

shape ArgType[T] {
    parse: Fun (.name: String, .argument: Option[String]) -> ParseResult[T],
}

union ParseResult[+T] =
    | Success[T] {
        value: T,
    }
    | Failure {
        message: String,
    };

val string = ArgType(
    .parse = fun (.name: String, .argument: Option[String]) -> ParseResult[String] {
        when (argument) {
            is Some {
                Success(.value = argument.value)
            }
            is None {
                Failure(.message = "required positional argument is missing: " + name)
            }
        }
    },
);

fun optional[T](argType: ArgType[T]) -> ArgType[Option[T]] {
    ArgType(
        .parse = fun(.name: String, .argument: Option[String]) -> ParseResult[Option[T]] {
            when (argument) {
                is Some {
                    val result = argType.parse(.name = name, .argument = argument);
                    when (result) {
                        is Success {
                            Success(.value = some(result.value))
                        }
                        is Failure {
                            result
                        }
                    }
                }
                is None {
                    Success(.value = none)
                }
            }
        }
    )
}

type StringArgs = Lists.List[#(String, String)];

fun parser[T](initialValue: T) -> Parser[T] {
    Parser(
        .argDefinitions = Lists.list(),
        .parseStringArgs = fun (stringArgs: StringArgs) => Success(.value = initialValue),
    )
}

fun parse[T](parser: Parser[T], args: Lists.List[String]) -> ParseResult[T] {
    val stringArgs = toStringArgs(Lists.reverse(parser.argDefinitions), args);
    parser.parseStringArgs(stringArgs)
}

fun toStringArgs(argDefinitions: Lists.List[ArgDefinition], args: Lists.List[String]) -> StringArgs {
    when (argDefinitions) {
        is Lists.Cons {
            val argDefinition = argDefinitions.head;
            when (args) {
                is Lists.Cons {
                    Lists.cons(
                        #(argDefinition.name, args.head),
                        toStringArgs(argDefinitions.tail, args.tail),
                    )
                }
                is Lists.Nil {
                    Lists.list()
                }
            }
        }
        is Lists.Nil {
            Lists.list()
        }
    }
}

fun positional[A, T, R](
    name: String,
    argType: ArgType[A],
    add: Fun (A, T) -> R,
    parser: Parser[T],
) -> Parser[R] {
    val argDefinition = ArgDefinition(
        .name = name,
    );

    Parser[R](
        .argDefinitions = Lists.cons(argDefinition, parser.argDefinitions),
        .parseStringArgs = fun (stringArgs: StringArgs) {
            val result = parser.parseStringArgs(stringArgs);
            when (result) {
                is Failure {
                    result
                }
                is Success {
                    val stringArg = findStringArg(stringArgs, name);
                    val result2 = argType.parse(.name = name, .argument = stringArg);
                    when (result2) {
                        is Failure {
                            result2
                        }
                        is Success {
                            Success(.value = add(result2.value, result.value))
                        }
                    }
                }
            }
        },
    )
}

fun findStringArg(stringArgs: StringArgs, name: String) -> Option[String] {
    stringArgs |> Lists.firstSome~(fun (stringArg: #(String, String)) {
        val #(argName, value) = stringArg;
        if (name == argName) {
            some(value)
        } else {
            none
        }
    })
}
