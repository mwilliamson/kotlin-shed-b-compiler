export ParseResult, Success, Failure, parser, parse, positional, option, optional, string;

import Lists from .Lists;
import Options from .Options;
import Sequences from .Sequences;
import UnicodeScalars from .Strings.UnicodeScalars;

shape Parser[T] {
    argDefinitions: ArgDefinitions,
    parseStringArgs: Fun (StringArgs) !ParseEffect -> T,
}

shape ArgDefinitions {
    positional: Lists.List[ArgDefinition],
    options: Lists.List[ArgDefinition],
}

shape ArgDefinition {
    name: String,
    isOption: Bool,
}

shape ArgType[T] {
    parse: Fun (.name: String, .argument: Option[String]) !ParseEffect -> T,
}

union ParseResult[+T] =
    | Success[T] {
        value: T,
    }
    | Failure {
        message: String,
    };

effect ParseEffect {
    .fail: (String) -> Nothing,
}

val string = ArgType(
    .parse = fun (.name: String, .argument: Option[String]) !ParseEffect -> String {
        when (argument) {
            is Some {
                argument.value
            }
            is None {
                ParseEffect.fail!("required positional argument is missing: " + name)
            }
        }
    },
);

fun optional[T](argType: ArgType[T]) -> ArgType[Option[T]] {
    ArgType(
        .parse = fun(.name: String, .argument: Option[String]) !ParseEffect -> Option[T] {
            when (argument) {
                is Some {
                    val result = argType.parse!(.name = name, .argument = argument);
                    some(result)
                }
                is None {
                    none
                }
            }
        }
    )
}

type StringArgs = Lists.List[#(String, String)];

fun parser[T](initialValue: T) -> Parser[T] {
    Parser(
        .argDefinitions = ArgDefinitions(
            .positional = Lists.list(),
            .options = Lists.list(),
        ),
        .parseStringArgs = fun (stringArgs: StringArgs) => initialValue,
    )
}

fun parse[T](parser: Parser[T], args: Lists.List[String]) -> ParseResult[T] {
    val stringArgs = toStringArgs(
        .positional = Lists.reverse(parser.argDefinitions.positional),
        .options = Lists.reverse(parser.argDefinitions.options),
        .args = args,
    );
    handle ParseEffect {
        val result = parser.parseStringArgs!(stringArgs);
        Success(.value = result)
    } on {
        .fail = (message: String) {
            exit Failure(.message = message)
        }
    }
}

fun toStringArgs(
    .positional: Lists.List[ArgDefinition],
    .options: Lists.List[ArgDefinition],
    .args: Lists.List[String],
) -> StringArgs {
    // TODO: make this vaguely pleasant
    when (args) {
        is Lists.Cons {
            if (UnicodeScalars.startsWith("--", args.head)) {
                val tail = args.tail;
                when (tail) {
                    is Lists.Cons {
                        Lists.cons(
                            #(args.head, tail.head),
                            toStringArgs(
                                .positional = positional,
                                .options = options,
                                .args = tail.tail,
                            ),
                        )
                    }
                    is Lists.Nil {
                        // TODO: raise error (or otherwise handle -- test case!)
                        Lists.list()
                    }
                }
            } else {
                when (positional) {
                    is Lists.Cons {
                        val argDefinition = positional.head;
                        Lists.cons(
                            #(argDefinition.name, args.head),
                            // TODO: taking the tail isn't safe in the presence of options!
                            toStringArgs(
                                .positional = positional.tail,
                                .options = options,
                                .args = args.tail,
                            ),
                        )
                    }
                    is Lists.Nil {
                        Lists.list()
                    }
                }
            }
        }
        is Lists.Nil {
            Lists.list()
        }
    }
}

fun positional[A, T, R](
    name: String,
    argType: ArgType[A],
    add: Fun (A, T) -> R,
    parser: Parser[T],
) -> Parser[R] {
    val argDefinition = ArgDefinition(
        .name = name,
        .isOption = false,
    );

    Parser[R](
        .argDefinitions = ArgDefinitions.fields.positional.update(
            Lists.cons(argDefinition, parser.argDefinitions.positional),
            parser.argDefinitions,
        ),
        .parseStringArgs = fun (stringArgs: StringArgs) !ParseEffect {
            val otherArgs = parser.parseStringArgs!(stringArgs);
            val stringArg = lookup(stringArgs, name);
            val value = argType.parse!(.name = name, .argument = stringArg);
            add(value, otherArgs)
        },
    )
}

fun option[A, T, R](
    name: String,
    argType: ArgType[A],
    add: Fun (A, T) -> R,
    parser: Parser[T],
) -> Parser[R] {
    val argDefinition = ArgDefinition(
        .name = name,
        .isOption = true,
    );

    Parser[R](
        .argDefinitions = ArgDefinitions.fields.positional.update(
            Lists.cons(argDefinition, parser.argDefinitions.options),
            parser.argDefinitions,
        ),
        .parseStringArgs = fun (stringArgs: StringArgs) !ParseEffect {
            val otherArgs = parser.parseStringArgs!(stringArgs);
            val stringArg = lookup(stringArgs, name);
            val value = argType.parse!(.name = name, .argument = stringArg);
            add(value, otherArgs)
        },
    )
}

fun lookup[T](values: Lists.List[#(String, T)], name: String) -> Option[T] {
    values |> Lists.firstSome~(fun (pair: #(String, T)) {
        val #(argName, value) = pair;
        if (name == argName) {
            some(value)
        } else {
            none
        }
    })
}
