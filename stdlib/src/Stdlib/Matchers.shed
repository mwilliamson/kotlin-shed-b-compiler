export
    Matcher,

    Result,
    Success,
    Failure,
    success,
    failure,
    isSuccess,

    isBool,
    isInt,
    isString,

    has,
    hasField,
    isType,
    isTypeWith,

    allOf,
    anything,
    isNone,
    isSome;

import Lists from .Lists;
import @(
    .Matcher as Matcher,
    .Result as Result,
    .Success as Success,
    .Failure as Failure,
    .success as success,
    .failure as failure,
    .isSuccess as isSuccess,
) from .Matchers.Core;
import @(
    .isBool as isBool,
    .isInt as isInt,
    .isString as isString,
) from .Matchers.Equality;
import @(
    .has as has,
    .hasField as hasField,
    .isType as isType,
    .isTypeWith as isTypeWith,
) from .Matchers.Type;
import Options from .Options;
import UnicodeScalars from .Strings.UnicodeScalars;

fun allOf[T](matchers: Lists.List[Matcher[T]]) -> Matcher[T] {
    Matcher(
        // TODO: better formatting (bullet list?)
        .description = "all of: " + UnicodeScalars.join(
            "; ",
            Lists.map(fun (matcher: Matcher[T]) => matcher.description, matchers),
        ),
        .match = fun (x: T) => Lists.firstSome(
            fun (matcher: Matcher[T]) {
                val result = matcher.match(x);
                when (result) {
                    is Success {
                        none
                    }
                    is Failure {
                        some(result)
                    }
                }
            },
            matchers,
        ) |> Options.default~(success),
    )
}

fun anything() -> Matcher[Top] {
    Matcher(
        .description = "anything",
        .match = fun (x: Top) => success,
    )
}

fun isNone() -> Matcher[Option[Top]] {
    Matcher(
        .description = "none",
        .match = fun (actual: Option[Top]) -> Result {
            if (actual is None) {
                success
            } else {
                failure("was some()")
            }
        }
    )
}

fun isSome[T](matcher: Matcher[T]) -> Matcher[Option[T]] {
    Matcher(
        .description = "option with value " + matcher.description,
        .match = fun (actual: Option[T]) -> Result {
            if (actual is Some[T]) {
                matcher.match(actual.value)
            } else {
                failure("was none")
            }
        }
    )
}
