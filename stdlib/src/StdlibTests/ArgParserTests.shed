export testCases;

import ArgParser from Stdlib.ArgParser;
import @(.list as list) from Stdlib.Lists;
import M from Stdlib.Matchers;
import Options from Stdlib.Options;
import Tests from Stdlib.Tests;

fun optionToString(option: Option[String]) -> String {
    when (option) {
        is None {
            "(none)"
        }
        is Some {
            option.value
        }
    }
}

val testCases = Tests.suite(moduleName, list(
    Tests.testCase("can parse single positional argument", fun () {
        shape Args {
            x: Option[String],
        }

        val rawArguments = list("hello");
        val argParser = ArgParser.parser(empty[Args]())
            |> ArgParser.positional~("message", ArgParser.string, Args.fields.x.update);

        val arguments = ArgParser.parse(argParser, rawArguments);

        Tests.assertThat(arguments, M.hasField(Args.fields.x, M.isSome(M.isString("hello"))))
    }),

    Tests.testCase("can parse multiple positional argument", fun () {
        shape Args {
            one: Option[String],
            two: Option[String],
            three: Option[String],
        }

        val rawArguments = list("hello", "world", "!");

        val argParser = ArgParser.parser(empty[Args]())
            |> ArgParser.positional~("one", ArgParser.string, Args.fields.one.update)
            |> ArgParser.positional~("two", ArgParser.string, Args.fields.two.update)
            |> ArgParser.positional~("three", ArgParser.string, Args.fields.three.update);

        val arguments = ArgParser.parse(argParser, rawArguments);

        Tests.assertThat(arguments, M.allOf(list(
            M.hasField(Args.fields.one, M.isSome(M.isString("hello"))),
            M.hasField(Args.fields.two, M.isSome(M.isString("world"))),
            M.hasField(Args.fields.three, M.isSome(M.isString("!"))),
        )))
    }),
));
